# 应用举例

---

## 分布式锁应用场景

在分布式锁服务中，有一种最典型应用场景，就是通过对集群进行 Master 选举，来解决分布式系统中的单点故障。什么是分布式系统中的单点故障：通常分布式系统采用主从模式，就是一个主控机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当我们的主节点发生故障时，那么整个系统就都瘫痪了，那么我们把这种故障叫作单点故障。

### 主从模式分布式系统

![](/assets/import7849-1.png)

### 单点故障

![](/assets/import7849-2.png)

## 传统解决方案

传统方式是采用一个备用节点，这个备用节点定期给当前主节点发送 ping 包，主节点收到 ping 包以后向备用节点发送回复Ack，当备用节点收到回复的时候就会认为当前主节点还活着，让他继续提供服务。

![](/assets/import7849-3.png)

当主节点挂了，这时候备用节点收不到回复了，然后他就认为主节点挂了接替他成为主节点

![](/assets/import7849-4.png)

但是这种方式就是有一个隐患，就是网络问题，来看一网络问题会造成什么后果

![](/assets/import7849-5.png)

也就是说我们的主节点并没有挂，只是在回复的时候网络发生故障，这样我们的备用节点同样收不到回复，就会认为主节点挂了，然后备用节点将他的Master实例启动起来，这样我们的分布式系统当中就有了两个主节点也就是---**双Master**， 出现Master以后我们的从节点就会将它所做的事一部分汇报给了主节点，一部分汇报给了从节点，这样服务就全乱了。为了防止出现这种情况，我们引入了 Zookeeper，它虽然不能避免网络故障，但它能够保证每时每刻只有一个 Master。我么来看一下 Zookeeper 是如何实现的。

## Zookeeper 解决方案

### Master 启动

在引入了 Zookeeper 以后我们启动了两个主节点，"主节点-A"和"主节点-B"他们启动以后，都向 Zookeeper 去注册一个节点。我们 假设"主节点-A"锁注册的节点是"master-00001"，"主节点-B"注册的节点是"master-00002"，注册完以后进行选举，编号最小的节点将在选举中获胜获得锁成为主节点，也就是我们的"主节点-A"将会获得锁成为主节点，然后"主节点-B"将被阻塞成为一个备用节点。那么，通过这种方式就完成了对两个 Master 进程的调度。

![](/assets/import7849-6.png)

### Master 故障

如果"主节点-A"挂了，这时候他所注册的节点将被自动删除，Zookeeper 会自动感知节点的变化，然后再次发出选举，这时候"主节点-B"将在选举中获胜，替代"主节点-A"成为主节点。

![](/assets/import7849-7.png)

### Master 恢复

![](/assets/import7849-8.png)

如果主节点恢复了，他会再次向 Zookeeper 注册一个节点，这时候他注册的节点将会是"master-00003"，Zookeeper 会感知节点的变化再次发动选举，这时候"主节点-B"在选举中会再次获胜继续担任"主节点"，"主节点-A"会担任备用节点。